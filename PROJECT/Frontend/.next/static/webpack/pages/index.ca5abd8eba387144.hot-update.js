"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAttendance: function() { return /* binding */ getAttendance; },\n/* harmony export */   searchQuery: function() { return /* binding */ searchQuery; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n// // src/services/api.ts\n// interface BackendResponse {\n//     generated_response: string;\n//     error?: string;\n// }\n// interface AttendanceResponse {\n//     roll_number: string;\n//     attendance: string;\n//     error?: string;\n// }\n// export const searchQuery = async (query: string): Promise<{ summary: string; results: string[] }> => {\n//     try {\n//         const response = await fetch('http://localhost:5000/search', {\n//             method: 'POST',\n//             headers: {\n//                 'Content-Type': 'application/json',\n//             },\n//             body: JSON.stringify({ query }),\n//         });\n//         const data: BackendResponse = await response.json();\n//         if (response.ok && data.generated_response) {\n//             return { summary: data.generated_response, results: [] };\n//         } else {\n//             return { summary: data.error || 'Sorry, I couldn’t process that. Can you try again?', results: [] };\n//         }\n//     } catch (error) {\n//         console.error('Error fetching response from Flask backend:', error);\n//         throw new Error('Failed to fetch response from the server.');\n//     }\n// };\n// export const getAttendance = async (rollNumber: string): Promise<{ rollNumber: string; attendance: string }> => {\n//     try {\n//         const response = await fetch('http://localhost:5000/get-attendance', {\n//             method: 'POST',\n//             headers: {\n//                 'Content-Type': 'application/json',\n//             },\n//             body: JSON.stringify({ rollNumber }),\n//         });\n//         const data: AttendanceResponse = await response.json();\n//         if (response.ok && data.attendance) {\n//             return { rollNumber: data.roll_number, attendance: data.attendance };\n//         } else {\n//             throw new Error(data.error || 'Failed to fetch attendance.');\n//         }\n//     } catch (error) {\n//         console.error('Error fetching attendance:', error);\n//         throw error;\n//     }\n//   };\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:5000\";\nconst searchQuery = async (query)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/search\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                query\n            })\n        });\n        const data = await response.json();\n        if (response.ok && data.generated_response) {\n            return {\n                summary: data.generated_response,\n                results: []\n            };\n        } else {\n            return {\n                summary: data.error || \"Sorry, I couldn’t process that. Can you try again?\",\n                results: []\n            };\n        }\n    } catch (error) {\n        console.error(\"Error fetching response from Flask backend:\", error);\n        throw new Error(\"Failed to fetch response from the server.\");\n    }\n};\nconst getAttendance = async (rollNumber)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/get-attendance\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                rollNumber\n            })\n        });\n        const data = await response.json();\n        if (response.ok && data.attendance) {\n            return {\n                rollNumber: data.roll_number,\n                attendance: data.attendance\n            };\n        } else {\n            throw new Error(data.error || \"Failed to fetch attendance.\");\n        }\n    } catch (error) {\n        console.error(\"Error fetching attendance:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmljZXMvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLHNCQUFzQjtBQUN0QixJQUFJO0FBRUosaUNBQWlDO0FBQ2pDLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLElBQUk7QUFFSix5R0FBeUc7QUFDekcsWUFBWTtBQUNaLHlFQUF5RTtBQUN6RSw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLHNEQUFzRDtBQUN0RCxpQkFBaUI7QUFDakIsK0NBQStDO0FBQy9DLGNBQWM7QUFFZCwrREFBK0Q7QUFFL0Qsd0RBQXdEO0FBQ3hELHdFQUF3RTtBQUN4RSxtQkFBbUI7QUFDbkIsbUhBQW1IO0FBQ25ILFlBQVk7QUFDWix3QkFBd0I7QUFDeEIsK0VBQStFO0FBQy9FLHdFQUF3RTtBQUN4RSxRQUFRO0FBQ1IsS0FBSztBQUVMLG9IQUFvSDtBQUNwSCxZQUFZO0FBQ1osaUZBQWlGO0FBQ2pGLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsc0RBQXNEO0FBQ3RELGlCQUFpQjtBQUNqQixvREFBb0Q7QUFDcEQsY0FBYztBQUVkLGtFQUFrRTtBQUVsRSxnREFBZ0Q7QUFDaEQsb0ZBQW9GO0FBQ3BGLG1CQUFtQjtBQUNuQiw0RUFBNEU7QUFDNUUsWUFBWTtBQUNaLHdCQUF3QjtBQUN4Qiw4REFBOEQ7QUFDOUQsdUJBQXVCO0FBQ3ZCLFFBQVE7QUFDUixPQUFPO0FBRVAsTUFBTUEsZUFBZUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxzQkFBc0IsSUFBSTtBQWFwRCxNQUFNQyxjQUFjLE9BQU9DO0lBQzlCLElBQUk7UUFDQSxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYlAsY0FBYSxZQUFVO1lBQ25EUSxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ0wsZ0JBQWdCO1lBQ3BCO1lBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRVA7WUFBTTtRQUNqQztRQUVBLE1BQU1RLE9BQXdCLE1BQU1QLFNBQVNRLElBQUk7UUFFakQsSUFBSVIsU0FBU1MsRUFBRSxJQUFJRixLQUFLRyxrQkFBa0IsRUFBRTtZQUN4QyxPQUFPO2dCQUFFQyxTQUFTSixLQUFLRyxrQkFBa0I7Z0JBQUVFLFNBQVMsRUFBRTtZQUFDO1FBQzNELE9BQU87WUFDSCxPQUFPO2dCQUFFRCxTQUFTSixLQUFLTSxLQUFLLElBQUk7Z0JBQXNERCxTQUFTLEVBQUU7WUFBQztRQUN0RztJQUNKLEVBQUUsT0FBT0MsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsK0NBQStDQTtRQUM3RCxNQUFNLElBQUlFLE1BQU07SUFDcEI7QUFDSixFQUFFO0FBRUssTUFBTUMsZ0JBQWdCLE9BQU9DO0lBQ2hDLElBQUk7UUFDQSxNQUFNakIsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJQLGNBQWEsb0JBQWtCO1lBQzNEUSxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ0wsZ0JBQWdCO1lBQ3BCO1lBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRVc7WUFBVztRQUN0QztRQUVBLE1BQU1WLE9BQTJCLE1BQU1QLFNBQVNRLElBQUk7UUFFcEQsSUFBSVIsU0FBU1MsRUFBRSxJQUFJRixLQUFLVyxVQUFVLEVBQUU7WUFDaEMsT0FBTztnQkFBRUQsWUFBWVYsS0FBS1ksV0FBVztnQkFBRUQsWUFBWVgsS0FBS1csVUFBVTtZQUFDO1FBQ3ZFLE9BQU87WUFDSCxNQUFNLElBQUlILE1BQU1SLEtBQUtNLEtBQUssSUFBSTtRQUNsQztJQUNKLEVBQUUsT0FBT0EsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtRQUM1QyxNQUFNQTtJQUNWO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvYXBpLnRzPzk1NmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLy8gc3JjL3NlcnZpY2VzL2FwaS50c1xyXG4vLyBpbnRlcmZhY2UgQmFja2VuZFJlc3BvbnNlIHtcclxuLy8gICAgIGdlbmVyYXRlZF9yZXNwb25zZTogc3RyaW5nO1xyXG4vLyAgICAgZXJyb3I/OiBzdHJpbmc7XHJcbi8vIH1cclxuXHJcbi8vIGludGVyZmFjZSBBdHRlbmRhbmNlUmVzcG9uc2Uge1xyXG4vLyAgICAgcm9sbF9udW1iZXI6IHN0cmluZztcclxuLy8gICAgIGF0dGVuZGFuY2U6IHN0cmluZztcclxuLy8gICAgIGVycm9yPzogc3RyaW5nO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgY29uc3Qgc2VhcmNoUXVlcnkgPSBhc3luYyAocXVlcnk6IHN0cmluZyk6IFByb21pc2U8eyBzdW1tYXJ5OiBzdHJpbmc7IHJlc3VsdHM6IHN0cmluZ1tdIH0+ID0+IHtcclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo1MDAwL3NlYXJjaCcsIHtcclxuLy8gICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbi8vICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuLy8gICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcXVlcnkgfSksXHJcbi8vICAgICAgICAgfSk7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGRhdGE6IEJhY2tlbmRSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbi8vICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEuZ2VuZXJhdGVkX3Jlc3BvbnNlKSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB7IHN1bW1hcnk6IGRhdGEuZ2VuZXJhdGVkX3Jlc3BvbnNlLCByZXN1bHRzOiBbXSB9O1xyXG4vLyAgICAgICAgIH0gZWxzZSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB7IHN1bW1hcnk6IGRhdGEuZXJyb3IgfHwgJ1NvcnJ5LCBJIGNvdWxkbuKAmXQgcHJvY2VzcyB0aGF0LiBDYW4geW91IHRyeSBhZ2Fpbj8nLCByZXN1bHRzOiBbXSB9O1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVzcG9uc2UgZnJvbSBGbGFzayBiYWNrZW5kOicsIGVycm9yKTtcclxuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIuJyk7XHJcbi8vICAgICB9XHJcbi8vIH07XHJcblxyXG4vLyBleHBvcnQgY29uc3QgZ2V0QXR0ZW5kYW5jZSA9IGFzeW5jIChyb2xsTnVtYmVyOiBzdHJpbmcpOiBQcm9taXNlPHsgcm9sbE51bWJlcjogc3RyaW5nOyBhdHRlbmRhbmNlOiBzdHJpbmcgfT4gPT4ge1xyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjUwMDAvZ2V0LWF0dGVuZGFuY2UnLCB7XHJcbi8vICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4vLyAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbi8vICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJvbGxOdW1iZXIgfSksXHJcbi8vICAgICAgICAgfSk7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGRhdGE6IEF0dGVuZGFuY2VSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbi8vICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEuYXR0ZW5kYW5jZSkge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4geyByb2xsTnVtYmVyOiBkYXRhLnJvbGxfbnVtYmVyLCBhdHRlbmRhbmNlOiBkYXRhLmF0dGVuZGFuY2UgfTtcclxuLy8gICAgICAgICB9IGVsc2Uge1xyXG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIGF0dGVuZGFuY2UuJyk7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhdHRlbmRhbmNlOicsIGVycm9yKTtcclxuLy8gICAgICAgICB0aHJvdyBlcnJvcjtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX0FQSV9CQVNFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMFwiO1xyXG5cclxuaW50ZXJmYWNlIEJhY2tlbmRSZXNwb25zZSB7XHJcbiAgICBnZW5lcmF0ZWRfcmVzcG9uc2U6IHN0cmluZztcclxuICAgIGVycm9yPzogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXR0ZW5kYW5jZVJlc3BvbnNlIHtcclxuICAgIHJvbGxfbnVtYmVyOiBzdHJpbmc7XHJcbiAgICBhdHRlbmRhbmNlOiBzdHJpbmc7XHJcbiAgICBlcnJvcj86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNlYXJjaFF1ZXJ5ID0gYXN5bmMgKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPHsgc3VtbWFyeTogc3RyaW5nOyByZXN1bHRzOiBzdHJpbmdbXSB9PiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9zZWFyY2hgLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHF1ZXJ5IH0pLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhOiBCYWNrZW5kUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICAgIGlmIChyZXNwb25zZS5vayAmJiBkYXRhLmdlbmVyYXRlZF9yZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdW1tYXJ5OiBkYXRhLmdlbmVyYXRlZF9yZXNwb25zZSwgcmVzdWx0czogW10gfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdW1tYXJ5OiBkYXRhLmVycm9yIHx8ICdTb3JyeSwgSSBjb3VsZG7igJl0IHByb2Nlc3MgdGhhdC4gQ2FuIHlvdSB0cnkgYWdhaW4/JywgcmVzdWx0czogW10gfTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlc3BvbnNlIGZyb20gRmxhc2sgYmFja2VuZDonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLicpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEF0dGVuZGFuY2UgPSBhc3luYyAocm9sbE51bWJlcjogc3RyaW5nKTogUHJvbWlzZTx7IHJvbGxOdW1iZXI6IHN0cmluZzsgYXR0ZW5kYW5jZTogc3RyaW5nIH0+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2dldC1hdHRlbmRhbmNlYCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByb2xsTnVtYmVyIH0pLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhOiBBdHRlbmRhbmNlUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICAgIGlmIChyZXNwb25zZS5vayAmJiBkYXRhLmF0dGVuZGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcm9sbE51bWJlcjogZGF0YS5yb2xsX251bWJlciwgYXR0ZW5kYW5jZTogZGF0YS5hdHRlbmRhbmNlIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBhdHRlbmRhbmNlLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXR0ZW5kYW5jZTonLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiUkVBQ1RfQVBQX0FQSV9CQVNFX1VSTCIsInNlYXJjaFF1ZXJ5IiwicXVlcnkiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsImpzb24iLCJvayIsImdlbmVyYXRlZF9yZXNwb25zZSIsInN1bW1hcnkiLCJyZXN1bHRzIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJnZXRBdHRlbmRhbmNlIiwicm9sbE51bWJlciIsImF0dGVuZGFuY2UiLCJyb2xsX251bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/services/api.ts\n"));

/***/ })

});